package com.marchinelearning.project;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;

public class Main {
	static int numFamilies = 9;
	static int[] familyOccurrences;
	static int[] exampleCurrentIndex;
	
	static String[] top500Ngrams;
	static double[] top500InfoGain;
	static HashMap<Integer, List<String>> familyTrainingMap;
	
	static HashMap<String, Scanner> trainingFilesMap;
	
	public static void calcFamilyOccurrences () {
		familyTrainingMap = new HashMap<Integer, List<String>>();
		familyOccurrences = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0};
		
		trainingFilesMap = new HashMap<String, Scanner>();
		
		Scanner in;
		try {
			in = new Scanner(new File(Constants.trainLabelsFilename));
			in.nextLine();
			while(in.hasNext()) {
				String[] lineParts = in.nextLine().split(",");
				int familyNbr = Integer.parseInt(lineParts[1]) - 1;
				String malwareId = lineParts[0].replace("\"", "");
				
				familyOccurrences[familyNbr]++;
				
				if (!familyTrainingMap.containsKey(familyNbr)) {
					familyTrainingMap.put(familyNbr, new ArrayList<String>());
				}				
				
				File file = new File(Constants.path + malwareId + Constants.ngramsTrainingExampleSuffix);
				
				if (file.exists()) {
					familyTrainingMap.get(familyNbr).add(malwareId);
					trainingFilesMap.put(malwareId, new Scanner(file));
				}
			}
			
			in.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static void calcInfoGain() {
		top500Ngrams = new String[500];
		top500InfoGain = new double[500];
		
		int totalTrainingData = 0;
		for (int familyCount : familyOccurrences) {
			totalTrainingData += familyCount;
		}
		
		//1541 + 2478 + 2942 + 475 + 42 + 751 + 398 + 1228 + 1013;
		exampleCurrentIndex = new int[totalTrainingData];
		
		Arrays.fill(top500Ngrams, "");
		Arrays.fill(top500InfoGain, 0);
		Arrays.fill(exampleCurrentIndex, 0);
		
		Scanner completeNgramsListFile;
		
		double infoGain;
		double PV0, PV1;
		double[] PC = new double[numFamilies];
		double[] PV0C = new double[numFamilies];
		double[] PV1C = new double[numFamilies];
		
		int ngramCountInFamily;
		int ngramCountInData;
		int ngramIndex = -1;
		
		try {
			completeNgramsListFile = new Scanner(new File(Constants.ngramsListFilename));
			completeNgramsListFile.nextLine();
			
			while(completeNgramsListFile.hasNext()) {
				ngramIndex++;
				
				String line = completeNgramsListFile.nextLine();
				
				String ngram = line; //.substring(0, 11).replace(" ", "");
				infoGain = 0;
				ngramCountInData = 0;
				
				Arrays.fill(PC, 0);
				Arrays.fill(PV0C, 0);
				Arrays.fill(PV1C, 0);
				
				for (int i = 0; i < numFamilies; i++) {
					ngramCountInFamily = countNgramInFamily(ngram, i);
					
					PV1C[i] = (double)ngramCountInFamily / (double)familyOccurrences[i];
					PV0C[i] = 1.0 - PV1C[i];
					PC[i] = (double)familyOccurrences[i] / (double)totalTrainingData;
					
					ngramCountInData += ngramCountInFamily;
				}
				
				PV1 = (double)ngramCountInData / (double)totalTrainingData;
				PV0 = 1.0 - PV1;
				
				for (int i = 0; i < numFamilies; i++) {
					if (PV0 != 0) {
						infoGain += PV0C[i] * (Math.log(PV0C[i] / (PV0 * PC[i])) / Math.log(2));
					}
					
					if (PV1 != 0) {
						infoGain += PV1C[i] * (Math.log(PV1C[i] / (PV1 * PC[i])) / Math.log(2));
					}
				}
				
				if (ngramIndex < 500) {
					top500Ngrams[ngramIndex] = ngram;
					top500InfoGain[ngramIndex] = infoGain;
				}
				else {
					processNgramInfoGain(ngram, infoGain);
				}
			}
			
			completeNgramsListFile.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static int countNgramInFamily(String ngram, int familyNbr) throws FileNotFoundException {
		List<String> malwaresInFamily = familyTrainingMap.get(familyNbr);
		int ngramCountInFamily = 0;
		
		Scanner ngramsListFile;
		
		String ngramIterator;
		String line;
		
		for (String malwareId : malwaresInFamily) {
			ngramsListFile = trainingFilesMap.get(malwareId);
			ngramIterator = ""; 		
			
			while (ngramIterator.compareTo(ngram) < 0 && ngramsListFile.hasNext()) {
				line = ngramsListFile.nextLine();
				ngramIterator = line.substring(0, 11).replace(" ", "");
				
				if (ngramIterator.equals(ngram)) {
					ngramCountInFamily++;
				}
			}
			
			//ngramsListFile.close();
		}
		
		return ngramCountInFamily;
	}
	
	public static void processNgramInfoGain(String ngram, double infoGain) {
		double minInfoGain = top500InfoGain[0];
		int minInfoGainIndex = 0;
		
		for (int i = 1; i < 500; i++) {
			if (minInfoGain > top500InfoGain[i]) {
				minInfoGain = top500InfoGain[i];
				minInfoGainIndex = i;
			}
		}
		
		if (minInfoGain < infoGain) {
			top500InfoGain[minInfoGainIndex] = infoGain;
			top500Ngrams[minInfoGainIndex] = ngram;
		}
	}
	
	public static void generateTop500NgramsFile() {
		try {
			PrintWriter writer = new PrintWriter(Constants.path + "top500NGrams.txt");
			for (String ngram : top500Ngrams) {
				writer.println(ngram);
			}			
			
			writer.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
//		MergeNgrams.run();
		
		calcFamilyOccurrences();
		
		calcInfoGain();
		
		generateTop500NgramsFile();
	}
}
