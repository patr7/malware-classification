package com.marchinelearning.project;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;
import com.google.common.math.*;

public class InfoGainCalculator {
	private static final int NUM_FAMILIES = 9;
	private static final int N_GRAM_ITER_LEN = 11;
	private static int[] familyOccurrences;

	private static HashMap<Integer, List<String>> familyTrainingMap;
	private static HashMap<String, BufferedReader> trainingFilesMap;

	private static PriorityQueue<NgramEntity> infoGainHeap = new PriorityQueue<>();

	private InfoGainCalculator() {
	}

	public static void calcFamilyOccurrences() {
		familyTrainingMap = new HashMap<Integer, List<String>>();
		familyOccurrences = new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0};
		trainingFilesMap = new HashMap<String, BufferedReader>();

		Scanner in;
		try {
			in = new Scanner(new File(Constants.trainLabelsFilename));
			in.nextLine();

			while (in.hasNext()) {
				String[] lineParts = in.nextLine().split(",");
				int familyNbr = Integer.parseInt(lineParts[1]) - 1;
				String malwareId = lineParts[0].replace("\"", "");

				familyOccurrences[familyNbr]++;

				if (!familyTrainingMap.containsKey(familyNbr)) {
					familyTrainingMap.put(familyNbr, new ArrayList<String>());
				}

				File file = new File(Constants.NgramTrainingExamplesPath()
						+ malwareId + Constants.ngramsTrainingExampleSuffix);

				if (file.exists()) {
					familyTrainingMap.get(familyNbr).add(malwareId);
					trainingFilesMap.put(malwareId, new BufferedReader(new FileReader(file)));
				}
			}

			in.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	public static void calcInfoGain() throws Exception {
		int totalTrainingData = 0;
		for (int familyCount : familyOccurrences) {
			totalTrainingData += familyCount;
		}

		try {
			long start = System.currentTimeMillis();
			int count = 0;
			Scanner completeNgramsListFile = new Scanner(new File(Constants.ngramsListFilename));
			
			while (completeNgramsListFile.hasNext()) {
				int ngramCountInData = 0;
				double infoGain = 0.0;
				double[] PC = new double[NUM_FAMILIES];
				double[] PV0C = new double[NUM_FAMILIES];
				double[] PV1C = new double[NUM_FAMILIES];

				String ngram = completeNgramsListFile.nextLine();
				for (int i = 0; i < NUM_FAMILIES; i++) {
					int ngramCountInFamily = countNgramInFamily(ngram, i);

					PV1C[i] = (double) ngramCountInFamily / familyOccurrences[i];
					PV0C[i] = 1.0 - PV1C[i];
					PC[i] = (double) familyOccurrences[i] / totalTrainingData;

					ngramCountInData += ngramCountInFamily;
				}

				double PV1 = (double) ngramCountInData / totalTrainingData;
				double PV0 = 1.0 - PV1;

				//System.out.println(ngram + ", " + PV1 + ", " + PV0);

				for (int i = 0; i < NUM_FAMILIES; i++) {
					if (PV0 != 0 && PV0C[i] != 0) {
						infoGain += PV0C[i] * DoubleMath.log2(PV0C[i] / (PV0 * PC[i]));
					}
					if (PV1 != 0 && PV1C[i] != 0) {
						infoGain += PV1C[i] * DoubleMath.log2(PV1C[i] / (PV1 * PC[i]));
					}
				}
				//System.out.println(infoGain);
				
				NgramEntity entity = new NgramEntity(ngram, infoGain);
				if (infoGainHeap.size() <= 500) {
					infoGainHeap.add(entity);
				}
				if (infoGainHeap.size() > 500 && entity.infoGain > infoGainHeap.peek().infoGain) {
					infoGainHeap.poll();
					infoGainHeap.add(entity);
				}
				
				count++;
				if (count % 1000 == 0)
					System.out.println(count + " : " + (System.currentTimeMillis() - start) + " ms");
			}

			completeNgramsListFile.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

	}
	
	private static int countNgramInFamily(String ngram, int familyNbr) throws IOException {
		int ngramCountInFamily = 0;
		List<String> malwaresInFamily = familyTrainingMap.get(familyNbr);
		
		for (String malwareId : malwaresInFamily) {
			BufferedReader ngramsListFile = trainingFilesMap.get(malwareId);
			ngramsListFile.mark(64);

			String ngramIterator;
			if ((ngramIterator = ngramsListFile.readLine()) != null) {
				int ngramCharIndex = 0;
				int i = 0;

				while (i < N_GRAM_ITER_LEN) {
					char c = ngramIterator.charAt(i);
					if (c == ' ') {
						i++;
					}
					else {
						if (c == ngram.charAt(ngramCharIndex)) {
							ngramCharIndex++;
							if (ngramCharIndex == ngram.length()) {
								ngramCountInFamily++;
								break;
							}
							i++;
						}
						else {
							ngramsListFile.reset();
							break;
						}
					}
				}
			}
		}

		return ngramCountInFamily;
	}

	public static void generateTop500NgramsFile() {
		try {
			PrintWriter writer = new PrintWriter(Constants.Path() + "top500NGrams.txt");
			for (NgramEntity entity : infoGainHeap) {
				writer.println(entity.ngramId);
			}

			writer.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	private static class NgramEntity implements Comparable<NgramEntity> {
		String ngramId;
		double infoGain;

		public NgramEntity(String ngramId, double infoGain) {
			this.ngramId = ngramId;
			this.infoGain = infoGain;
		}

		@Override
		public int compareTo(NgramEntity other) {
			return Double.compare(this.infoGain, other.infoGain);
		}
	}

	public static void main(String[] args) throws Exception {
		// MergeNgrams.run();
		calcFamilyOccurrences();
		calcInfoGain();
		//generateTop500NgramsFile();

	}
}
