package com.marchinelearning.project;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

import com.google.common.math.*;

public class InfoGainCalculator {
	private static final int NUM_FAMILIES = 9;
	private static final int N_GRAM_ITER_LEN = 11;
	private static int[] familyOccurrences;

	private static HashMap<Integer, List<String>> familyTrainingMap;
	private static HashMap<String, BufferedReader> trainingFilesMap;

	//private static PriorityQueue<NgramEntity> infoGainHeap = new PriorityQueue<>();
	private static PriorityQueue<AttrEntity> infoGainHeap = new PriorityQueue<>();
	private InfoGainCalculator() {
	}

	public static void calcFamilyOccurrences(String trainingExamplesPath, String trainingExamplesSuffix) {
		familyTrainingMap = new HashMap<Integer, List<String>>();
		familyOccurrences = new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0};
		trainingFilesMap = new HashMap<String, BufferedReader>();

		Scanner in;
		try {
			in = new Scanner(new File(Constants.trainLabelsFilename));
			in.nextLine();

			while (in.hasNext()) {
				String[] lineParts = in.nextLine().split(",");
				int familyNbr = Integer.parseInt(lineParts[1]) - 1;
				String malwareId = lineParts[0].replace("\"", "");

				familyOccurrences[familyNbr]++;

				if (!familyTrainingMap.containsKey(familyNbr)) {
					familyTrainingMap.put(familyNbr, new ArrayList<String>());
				}
				System.out.println(trainingExamplesPath + malwareId + trainingExamplesSuffix);
				File file = new File(trainingExamplesPath + malwareId + trainingExamplesSuffix);

				if (file.exists()) {
					familyTrainingMap.get(familyNbr).add(malwareId);
					trainingFilesMap.put(malwareId, new BufferedReader(new FileReader(file)));
				}
			}

			in.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	public static void calcInfoGain(String totalAttrListFileName, boolean useNGrams) throws Exception {
		int totalTrainingData = 0;
		for (int familyCount : familyOccurrences) {
			totalTrainingData += familyCount;
		}

		try {
			long start = System.currentTimeMillis();
			int count = 0;
			Scanner completeAttrListFile = new Scanner(new File(totalAttrListFileName));
			
			while (completeAttrListFile.hasNext()) {
				int attrCountInData = 0;
				double infoGain = 0.0;
				double[] PC = new double[NUM_FAMILIES];
				double[] PV0C = new double[NUM_FAMILIES];
				double[] PV1C = new double[NUM_FAMILIES];

				String attr = completeAttrListFile.nextLine();
				for (int i = 0; i < NUM_FAMILIES; i++) {
					int attrCountInFamily = (useNGrams) ? countNgramInFamily(attr, i) : countAttrInFamily(attr, i);

					PV1C[i] = (double) attrCountInFamily / familyOccurrences[i];
					PV0C[i] = 1.0 - PV1C[i];
					PC[i] = (double) familyOccurrences[i] / totalTrainingData;

					attrCountInData += attrCountInFamily;
				}

				double PV1 = (double) attrCountInData / totalTrainingData;
				double PV0 = 1.0 - PV1;

			//System.out.println(attr + ", " + PV1 + ", " + PV0);

				for (int i = 0; i < NUM_FAMILIES; i++) {
					if (PV0 != 0 && PV0C[i] != 0) {
						infoGain += PV0C[i] * DoubleMath.log2(PV0C[i] / (PV0 * PC[i]));
					}
					if (PV1 != 0 && PV1C[i] != 0) {
						infoGain += PV1C[i] * DoubleMath.log2(PV1C[i] / (PV1 * PC[i]));
					}
				}
				//System.out.println(infoGain);
				
				//NgramEntity entity = new NgramEntity(attr, infoGain);
				AttrEntity entity =  new AttrEntity(attr, infoGain);
				if (infoGainHeap.size() <= 500) {
					infoGainHeap.add(entity);
				}
				if (infoGainHeap.size() > 500 && entity.infoGain > infoGainHeap.peek().infoGain) {
					infoGainHeap.poll();
					infoGainHeap.add(entity);
				}
				
				count++;
				if (count % 100000 == 0)
					System.out.println(count + " : " + (System.currentTimeMillis() - start) + " ms");
			}

			completeAttrListFile.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

	}
	
	private static int countAttrInFamily(String attr, int familyNbr) throws IOException {
		int attrCountInFamily = 0;
		List<String> malwaresInFamily = familyTrainingMap.get(familyNbr);
		
		for (String malwareId : malwaresInFamily) {
			BufferedReader attrListFile = trainingFilesMap.get(malwareId);
			attrListFile.mark(64);

			String attrIterator;
			if ((attrIterator = attrListFile.readLine()) != null) {
				
				if (attrIterator.equalsIgnoreCase(attr)) {
					attrCountInFamily++;
				
				}
				else
					attrListFile.reset();
			}
		}

		return attrCountInFamily;
	}

	private static int countNgramInFamily(String ngram, int familyNbr) throws IOException {
		int ngramCountInFamily = 0;
		List<String> malwaresInFamily = familyTrainingMap.get(familyNbr);
		
		for (String malwareId : malwaresInFamily) {
			BufferedReader ngramsListFile = trainingFilesMap.get(malwareId);
			ngramsListFile.mark(64);

			String ngramIterator;
			if ((ngramIterator = ngramsListFile.readLine()) != null) {
				int ngramCharIndex = 0;
				int i = 0;

				while (i < N_GRAM_ITER_LEN) {
					char c = ngramIterator.charAt(i);
					if (c == ' ') {
						i++;
					}
					else {
						if (c == ngram.charAt(ngramCharIndex)) {
							ngramCharIndex++;
							if (ngramCharIndex == ngram.length()) {
								ngramCountInFamily++;
								break;
							}
							i++;
						}
						else {
							ngramsListFile.reset();
							break;
						}
					}
				}
			}
		}

		return ngramCountInFamily;
	}

	public static void generateTop500AttrsFile(String masterAttrList) {
		try {
			PrintWriter writer = new PrintWriter(new File(masterAttrList));
			for (AttrEntity entity : infoGainHeap) {
				writer.println(entity.attrId);
			}

			writer.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	private static class NgramEntity implements Comparable<Object> {
		String ngramId;
		double infoGain;

		public NgramEntity(String ngramId, double infoGain) {
			this.ngramId = ngramId;
			this.infoGain = infoGain;
		}

		@Override
		public int compareTo(Object other) {
			NgramEntity otherNGram = (NgramEntity) other;
			return Double.compare(this.infoGain, otherNGram.infoGain);
		}
	}
	
	private static class AttrEntity implements Comparable<AttrEntity> {
		String attrId;
		double infoGain;

		public AttrEntity(String attrId, double infoGain) {
			this.attrId = attrId;
			this.infoGain = infoGain; 
		}

		@Override
		public int compareTo(AttrEntity other) {
			return Double.compare(this.infoGain, other.infoGain);
		}
	}

	public static void main(String[] args) throws Exception {
		// MergeNgrams.run();
		/*calcFamilyOccurrences(Constants.NgramTrainingExamplesPath(), Constants.ngramsTrainingExampleSuffix);
		calcInfoGain(Constants.ngramsListFilename, true);
		generateTop500AttrsFile(Constants.masterAttrList);
	*/
		calcFamilyOccurrences(Constants.apiStringsPath, ".asm");
		calcInfoGain(Constants.apiListFilename, false);
		generateTop500AttrsFile(Constants.apiMasterAttrList);
	}
}
